$[ import "../util/ReleaseFunctions" ]
$[ function GetById
   (entity
   ) ]
    $[ call CheckIfReleasedEntity(entity: entity)->(isReleasedEntity: isReleasedEntity) ]
    //
    // GET ${entity|title} BY ID
    //
    func get${entity.name}ById($[ if isReleasedEntity ]releaseId:UUID, $[/ if ]id: UUID, completion: @escaping (${entity.name}?, Error?) -> Void) {
        let idStr = id.uuidString
        let urlString = restServerBaseUrl + "/${entity|domain:APIPath|name}/\(idStr)?levels=0$[ if isReleasedEntity ]&releaseId=\(releaseId)$[/ if ]"
        print("API: \(urlString)")

        guard let url = URL(string: urlString) else {
            print("Invalid URL")
            completion(nil, NSError(domain: "Invalid URL", code: 400, userInfo: nil))
            return
        }
        var request = URLRequest(url: url)
        request.setValue("application/json", forHTTPHeaderField: "Accept")

        URLSession.shared.dataTask(with: request) { data, response, error in
            guard let data = data, error == nil else {
                completion(nil, error)
                return
            }

            do {
                let returnedObject = try JSONDecoder().decode(${entity.name}.self, from: data)
                completion(returnedObject, nil)
            } catch let jsonError {
                completion(nil, jsonError)
            }
        }.resume()
    }
$[/ function ]
$[ function GetList
   (entity,
    relationship
   ) ]
    $[ let isGetBy = relationship != null ]
    $[ let getByComment = "" ]
    $[ let methodSuffix = "" ]
    $[ let parentIdArg = "" ]
    $[ let urlPathSuffix = "" ]
    $[ let toEntity = relationship.to.entity ]
    $[ let isToReleasedEntity = false ]
    $[ call CheckIfReleasedEntity(entity: entity)->(isReleasedEntity: isReleasedEntity) ]
    $[ if isGetBy ]
        $[ capture getByComment ] BY ${relationship|title}$[/ capture ]
        $[ assert toEntity.hasPrimaryKey fatal ]${toEntity|name} must have a primary key!$[/ assert ]
        $[ let toEntityPK = toEntity.primaryKeyAttribute ]
        $[ capture methodSuffix ]By${relationship|name|capitalize}$[/ capture ]
        $[ capture parentIdArg ]id: ${toEntityPK.type|language}, $[/ capture ]
        $[ capture urlPathSuffix ]/${relationship|domain:APIPath|name}/\(id)$[/ capture ]
    $[/ if ]
    //
    // GET ${entity|title} LIST${getByComment}
    //
    func get${entity.name}List${methodSuffix}($[ if isReleasedEntity ]releaseId:UUID, $[/ if ]${parentIdArg}completion: @escaping ([${entity.name}]?, Error?) -> Void) {
        let urlString = restServerBaseUrl + "/${entity|domain:APIPath|name}${urlPathSuffix}?limit=10000&levels=0$[ if isReleasedEntity ]&releaseId=\(releaseId)$[/ if ]"
        print("API: \(urlString)")

        guard let url = URL(string: urlString) else {
            print("Invalid URL")
            completion(nil, NSError(domain: "Invalid URL", code: 400, userInfo: nil))
            return
        }
        var request = URLRequest(url: url)
        request.setValue("application/json", forHTTPHeaderField: "Accept")

        URLSession.shared.dataTask(with: request) { data, response, error in
            guard let data = data, error == nil else {
                completion(nil, error)
                return
            }

            do {
                let returnedObject = try JSONDecoder().decode([${entity.name}].self, from: data)
                completion(returnedObject, nil)
            } catch let DecodingError.dataCorrupted(context) {
                print(context)
            } catch let DecodingError.keyNotFound(key, context) {
                print("Key '\(key)' not found:", context.debugDescription)
                print("codingPath:", context.codingPath)
            } catch let DecodingError.valueNotFound(value, context) {
                print("Value '\(value)' not found:", context.debugDescription)
                print("codingPath:", context.codingPath)
            } catch let DecodingError.typeMismatch(type, context)  {
                print("Type '\(type)' mismatch:", context.debugDescription)
                print("codingPath:", context.codingPath)
            } catch let jsonError {
                completion(nil, jsonError)
            } catch {
                print("error: ", error)
            }
        }.resume()
    }
$[/ function ]